package test.cayenne.OMOP.auto;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

import org.apache.cayenne.BaseDataObject;
import org.apache.cayenne.exp.Property;

import test.cayenne.OMOP.Concept;

/**
 * Class _ConceptAncestor was generated by Cayenne.
 * It is probably a good idea to avoid changing this class manually,
 * since it may be overwritten next time code is regenerated.
 * If you need to make any customizations, please use subclass.
 */
public abstract class _ConceptAncestor extends BaseDataObject {

    private static final long serialVersionUID = 1L; 

    public static final String ANCESTOR_CONCEPT_ID_PK_COLUMN = "ancestor_concept_id";
    public static final String DESCENDANT_CONCEPT_ID_PK_COLUMN = "descendant_concept_id";

    public static final Property<Integer> ANCESTOR_CONCEPT_ID = Property.create("ancestorConceptId", Integer.class);
    public static final Property<Integer> DESCENDANT_CONCEPT_ID = Property.create("descendantConceptId", Integer.class);
    public static final Property<Integer> MAX_LEVELS_OF_SEPARATION = Property.create("maxLevelsOfSeparation", Integer.class);
    public static final Property<Integer> MIN_LEVELS_OF_SEPARATION = Property.create("minLevelsOfSeparation", Integer.class);
    public static final Property<Concept> ASCENDANT_CONCEPT = Property.create("ascendantConcept", Concept.class);
    public static final Property<Concept> DESCENDANT_CONCEPT = Property.create("descendantConcept", Concept.class);

    protected int ancestorConceptId;
    protected int descendantConceptId;
    protected int maxLevelsOfSeparation;
    protected int minLevelsOfSeparation;

    protected Object ascendantConcept;
    protected Object descendantConcept;

    public void setAncestorConceptId(int ancestorConceptId) {
        beforePropertyWrite("ancestorConceptId", this.ancestorConceptId, ancestorConceptId);
        this.ancestorConceptId = ancestorConceptId;
    }

    public int getAncestorConceptId() {
        beforePropertyRead("ancestorConceptId");
        return this.ancestorConceptId;
    }

    public void setDescendantConceptId(int descendantConceptId) {
        beforePropertyWrite("descendantConceptId", this.descendantConceptId, descendantConceptId);
        this.descendantConceptId = descendantConceptId;
    }

    public int getDescendantConceptId() {
        beforePropertyRead("descendantConceptId");
        return this.descendantConceptId;
    }

    public void setMaxLevelsOfSeparation(int maxLevelsOfSeparation) {
        beforePropertyWrite("maxLevelsOfSeparation", this.maxLevelsOfSeparation, maxLevelsOfSeparation);
        this.maxLevelsOfSeparation = maxLevelsOfSeparation;
    }

    public int getMaxLevelsOfSeparation() {
        beforePropertyRead("maxLevelsOfSeparation");
        return this.maxLevelsOfSeparation;
    }

    public void setMinLevelsOfSeparation(int minLevelsOfSeparation) {
        beforePropertyWrite("minLevelsOfSeparation", this.minLevelsOfSeparation, minLevelsOfSeparation);
        this.minLevelsOfSeparation = minLevelsOfSeparation;
    }

    public int getMinLevelsOfSeparation() {
        beforePropertyRead("minLevelsOfSeparation");
        return this.minLevelsOfSeparation;
    }

    public void setAscendantConcept(Concept ascendantConcept) {
        setToOneTarget("ascendantConcept", ascendantConcept, true);
    }

    public Concept getAscendantConcept() {
        return (Concept)readProperty("ascendantConcept");
    }

    public void setDescendantConcept(Concept descendantConcept) {
        setToOneTarget("descendantConcept", descendantConcept, true);
    }

    public Concept getDescendantConcept() {
        return (Concept)readProperty("descendantConcept");
    }

    @Override
    public Object readPropertyDirectly(String propName) {
        if(propName == null) {
            throw new IllegalArgumentException();
        }

        switch(propName) {
            case "ancestorConceptId":
                return this.ancestorConceptId;
            case "descendantConceptId":
                return this.descendantConceptId;
            case "maxLevelsOfSeparation":
                return this.maxLevelsOfSeparation;
            case "minLevelsOfSeparation":
                return this.minLevelsOfSeparation;
            case "ascendantConcept":
                return this.ascendantConcept;
            case "descendantConcept":
                return this.descendantConcept;
            default:
                return super.readPropertyDirectly(propName);
        }
    }

    @Override
    public void writePropertyDirectly(String propName, Object val) {
        if(propName == null) {
            throw new IllegalArgumentException();
        }

        switch (propName) {
            case "ancestorConceptId":
                this.ancestorConceptId = val == null ? 0 : (int)val;
                break;
            case "descendantConceptId":
                this.descendantConceptId = val == null ? 0 : (int)val;
                break;
            case "maxLevelsOfSeparation":
                this.maxLevelsOfSeparation = val == null ? 0 : (int)val;
                break;
            case "minLevelsOfSeparation":
                this.minLevelsOfSeparation = val == null ? 0 : (int)val;
                break;
            case "ascendantConcept":
                this.ascendantConcept = val;
                break;
            case "descendantConcept":
                this.descendantConcept = val;
                break;
            default:
                super.writePropertyDirectly(propName, val);
        }
    }

    private void writeObject(ObjectOutputStream out) throws IOException {
        writeSerialized(out);
    }

    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        readSerialized(in);
    }

    @Override
    protected void writeState(ObjectOutputStream out) throws IOException {
        super.writeState(out);
        out.writeInt(this.ancestorConceptId);
        out.writeInt(this.descendantConceptId);
        out.writeInt(this.maxLevelsOfSeparation);
        out.writeInt(this.minLevelsOfSeparation);
        out.writeObject(this.ascendantConcept);
        out.writeObject(this.descendantConcept);
    }

    @Override
    protected void readState(ObjectInputStream in) throws IOException, ClassNotFoundException {
        super.readState(in);
        this.ancestorConceptId = in.readInt();
        this.descendantConceptId = in.readInt();
        this.maxLevelsOfSeparation = in.readInt();
        this.minLevelsOfSeparation = in.readInt();
        this.ascendantConcept = in.readObject();
        this.descendantConcept = in.readObject();
    }

}
